<!-- products/index.ejs -->
<%- include('partials/head', { title: 'Data' }) %>

<style>
    .area {
      fill: steelblue;
      clip-path: url(#clip);
    }
    
    .zoom {
      cursor: move;
      fill: none;
      pointer-events: all;
    }
</style>
<head>
    <script src="https://d3js.org/d3.v6.min.js"></script> <!-- I don't think this line of code does anything? Probably safe to remove -->

    <script>

        var svg = d3.select("svg"),
            margin = {top: 20, right: 20, bottom: 110, left: 40},
            margin2 = {top: 430, right: 20, bottom: 30, left: 40},
            width = +svg.attr("width") - margin.left - margin.right,
            height = +svg.attr("height") - margin.top - margin.bottom,
            height2 = +svg.attr("height") - margin2.top - margin2.bottom;
        
        var parseDate = d3.timeParse("%b %Y");
        
        var x = d3.scaleTime().range([0, width]),
            x2 = d3.scaleTime().range([0, width]),
            y = d3.scaleLinear().range([height, 0]),
            y2 = d3.scaleLinear().range([height2, 0]);
        
        var xAxis = d3.axisBottom(x),
            xAxis2 = d3.axisBottom(x2),
            yAxis = d3.axisLeft(y);
        
        var brush = d3.brushX()
            .extent([[0, 0], [width, height2]])
            .on("brush end", brushed);
        
        var zoom = d3.zoom()
            .scaleExtent([1, Infinity])
            .translateExtent([[0, 0], [width, height]])
            .extent([[0, 0], [width, height]])
            .on("zoom", zoomed);
        
        var area = d3.area()
            .curve(d3.curveMonotoneX)
            .x(function(d) { return x(d.date); })
            .y0(height)
            .y1(function(d) { return y(d.price); });
        
        var area2 = d3.area()
            .curve(d3.curveMonotoneX)
            .x(function(d) { return x2(d.date); })
            .y0(height2)
            .y1(function(d) { return y2(d.price); });
        
        svg.append("defs").append("clipPath")
            .attr("id", "clip")
          .append("rect")
            .attr("width", width)
            .attr("height", height);
        
        var focus = svg.append("g")
            .attr("class", "focus")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        
        var context = svg.append("g")
            .attr("class", "context")
            .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");
        
        d3.csv("sp500.csv", type, function(error, data) {
          if (error) throw error;
        
          x.domain(d3.extent(data, function(d) { return d.date; }));
          y.domain([0, d3.max(data, function(d) { return d.price; })]);
          x2.domain(x.domain());
          y2.domain(y.domain());
        
          focus.append("path")
              .datum(data)
              .attr("class", "area")
              .attr("d", area);
        
          focus.append("g")
              .attr("class", "axis axis--x")
              .attr("transform", "translate(0," + height + ")")
              .call(xAxis);
        
          focus.append("g")
              .attr("class", "axis axis--y")
              .call(yAxis);
        
          context.append("path")
              .datum(data)
              .attr("class", "area")
              .attr("d", area2);
        
          context.append("g")
              .attr("class", "axis axis--x")
              .attr("transform", "translate(0," + height2 + ")")
              .call(xAxis2);
        
          context.append("g")
              .attr("class", "brush")
              .call(brush)
              .call(brush.move, x.range());
        
          svg.append("rect")
              .attr("class", "zoom")
              .attr("width", width)
              .attr("height", height)
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
              .call(zoom);
        });
        
        function brushed() {
          if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
          var s = d3.event.selection || x2.range();
          x.domain(s.map(x2.invert, x2));
          focus.select(".area").attr("d", area);
          focus.select(".axis--x").call(xAxis);
          svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
              .scale(width / (s[1] - s[0]))
              .translate(-s[0], 0));
        }
        
        function zoomed() {
          if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; // ignore zoom-by-brush
          var t = d3.event.transform;
          x.domain(t.rescaleX(x2).domain());
          focus.select(".area").attr("d", area);
          focus.select(".axis--x").call(xAxis);
          context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
        }
        
        function type(d) {
          d.date = parseDate(d.date);
          d.price = +d.price;
          return d;
        }
        
        </script>

    <script type="module">
    import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

    /*
    WORKS
    // Declare the chart dimensions and margins.
    const width = 640;
    const height = 400;
    const marginTop = 20;
    const marginRight = 20;
    const marginBottom = 30;
    const marginLeft = 40;

    // Initial time range
    let startDate = new Date("2025-01-01");
    let endDate = new Date("2026-01-01");

    // Declare the x (horizontal position) scale.
    const x = d3.scaleUtc()
        .domain([startDate, endDate])
        .range([marginLeft, width - marginRight]);

    // Declare the y (vertical position) scale.
    const y = d3.scaleLinear()
        .domain([0, 100])
        .range([height - marginBottom, marginTop]);

    // Create the SVG container.
    const svg = d3.create("svg")
        .attr("width", width)
        .attr("height", height);

    // Add the x-axis.
    const xAxis = svg.append("g")
        .attr("transform", `translate(0,${height - marginBottom})`)
        .call(d3.axisBottom(x));

    // Add the y-axis.
    svg.append("g")
        .attr("transform", `translate(${marginLeft},0)`)
        .call(d3.axisLeft(y));

    // Append the SVG element to the container.
    document.getElementById("chart-container").appendChild(svg.node());

    // Handle slider changes
    document.getElementById("time-slider").addEventListener("input", function(event) {
        const newStartDate = new Date(parseInt(event.target.value));
        const newEndDate = new Date(newStartDate);
        newEndDate.setFullYear(newEndDate.getFullYear() + 1); // Keep a 1-year range

        // Update the x scale
        x.domain([newStartDate, newEndDate]);

        // Update the x-axis
        xAxis.transition().duration(500).call(d3.axisBottom(x));
    });
    */

    /*
    DIDN'T WORK IDK WHY:
        // Specify the dimensions of the chart.
        const width = 928;
        const height = 600;
        const marginTop = 20;
        const marginRight = 30;
        const marginBottom = 30;
        const marginLeft = 50;

        // Specify the horizontal (time) axis.
        const x = d3.scaleUtc()
            .domain(d3.extent(aapl, d => d.Date))
            .range([marginLeft, width - marginRight])

        // Specify the vertical axis.
        const y = d3.scaleLog()
            .domain([d3.min(aapl, d => d.Close / basis * 0.9), d3.max(aapl, d => d.Close / basis / 0.9)])
            .rangeRound([height - marginBottom, marginTop])

        // A format function that transforms 1.2 into "+20%", etc.
        const f = d3.format("+.0%");
        const format = x => x === 1 ? "0%" : f(x - 1);

        // Create the SVG container.
        const svg = d3.create("svg").attr("viewBox", [0, 0, width, height]);

        // Create the horizontal (date) axis.
        svg.append("g")
            .attr("transform", `translate(0,${y(1)})`)
            .call(d3.axisBottom(x).ticks(width / 80).tickSizeOuter(0))
            .call(g => g.select(".domain").remove());

        // Create the vertical axis, with grid lines.
        svg.append("g")
            .attr("transform", `translate(${marginLeft},0)`)
            .call(d3.axisLeft(y)
                .tickValues(d3.ticks(...y.domain(), 10))
                .tickFormat(format))
            .call(g => g.selectAll(".tick line").clone()
                .attr("stroke-opacity", d => d === 1 ? null : 0.2)
                .attr("x2", width - marginLeft - marginRight))
            .call(g => g.select(".domain").remove());

        // Create a line path that normalizes the value with respect to the base.
        const line = d3.line()
            .x(d => x(d.Date))
            .y(d => y(d.Close / basis));

        svg.append("path")
            .datum(aapl)
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            .attr("stroke-width", 1.5)
            .attr("stroke-linejoin", "round")
            .attr("stroke-linecap", "round")
            .attr("d", line);
        
        return svg.node();
    */
    </script>

</head>

<div class="index-container2">
    <span>
        <div class="landing-title">Soil Moisture vs. Time</div>
        <div class="landing-text">This chart tracks the soil moisture of our plant. If it falls under [THRESHOLD 1], the plant will automatically water itself. If it's too high above [THRESHOLD 2], the plant will be unable to be watered. If it's in between, feel free to click the "Water" button to water the plant from afar!</div>
        <!-- "Works", but not fully: <input id="time-slider" type="range" min="2025-01-01" max="2026-01-01" step="5" value="2025-01-01" style="width: 600px; margin-bottom: 10px;"> -->
        <div id="chart-container"></div>
        <svg width="960" height="500"></svg>
    </span>
</div>

<!--
        <script>
            function addToCart(product_id, product_name, product_price) {
                fetch('/addToCart', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        product_id, 
                        product_name, 
                        product_price, 
                    }),
                })
                .then(response => {
                    if(!response.ok) {
                        throw new Error(`HTTP Error! Status: ${response.status}`)
                    }
                })
            }

            function handleCheckout() {
                console.log("handle checkout")
                fetch('/checkout')
                .then(response => {
                    if(!response.ok) {
                        console.error("oh no");
                    } else {
                        console.log('rerouting');
                        window.location.href = `http://localhost:3000/checkout`;
                    }
                    console.log(response.text());
                })
            }
        </script>

  

        <div class="container" style="margin-top: 3%;">
            <ul class="product-list">
                <% products.forEach(product => { %>
                    <% if(product.display) { %>
                        <li class="product-list-item">
                            <span><img class="image-text" src="<%=product.product_image%>" alt="<%= product.product_name%> Image"></span>
                            <span class="product-text"><%= product.product_name %></span>
                            <span class="price-text">$<%= product.product_price %></span>
                            <span><button class="add-to-cart" onclick="addToCart('<%=product.product_id%>', '<%=product.product_name%>', '<%=product.product_price%>')"></button></span>
                        </li>
                    <% } %>
                <% }); %>
            </ul>
        </div>
-->